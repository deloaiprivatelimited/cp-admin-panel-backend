import uuid
from mongoengine import (
    Document,
    EmbeddedDocument,
    StringField,
    ListField,
    EmbeddedDocumentField,
    IntField,
    BooleanField,
    FloatField,
    DictField,
    ValidationError,
)


# ------------------------
# Embedded / Reusable
# ------------------------
class Image(EmbeddedDocument):
    """Reusable image structure with autogenerated id, label, url, alt text and optional metadata."""
    image_id = StringField(required=True, default=lambda: str(uuid.uuid4()))
    label = StringField()             # a human readable label for the image (optional)
    url = StringField(required=True)  # URL to the image (should be validated by caller)
    alt_text = StringField()          # alt / description text for accessibility
    metadata = DictField()            # any extra metadata (uploader, size, mime, etc.)


class Option(EmbeddedDocument):
    """Options for MCQ (reusable embedded doc)"""
    option_id = StringField(required=True, default=lambda: str(uuid.uuid4()))
    value = StringField(required=True)
    # allow multiple images per option (keeps compatibility and flexible)
    images = ListField(EmbeddedDocumentField(Image), default=list)


# ------------------------
# Shared Config per-collection
# ------------------------
class MCQConfig(Document):
    """Configuration auto-created/updated per collection of MCQs.

    collection_name allows keeping separate configs for `mcqs`, `course_mcqs`, etc.
    """
    collection_name = StringField(required=True, unique=True)
    difficulty_levels = ListField(StringField())
    topics = ListField(StringField())
    subtopics = ListField(StringField())
    tags = ListField(StringField())

    meta = {"collection": "mcq_configs"}


# ------------------------
# Abstract/Base MCQ model
# ------------------------
class BaseMCQ(Document):
    """Abstract base MCQ model that other concrete MCQ collections inherit from.

    Make changes here to affect all MCQ-like collections.
    """
    title = StringField(required=True)
    question_text = StringField(required=True)

    # question-level images (0..N)
    question_images = ListField(EmbeddedDocumentField(Image), default=list)

    options = ListField(EmbeddedDocumentField(Option), required=True)
    correct_options = ListField(StringField(), required=True)  # list of option_ids

    is_multiple = BooleanField(default=False)

    marks = FloatField(required=True, min_value=0)
    negative_marks = FloatField(required=True, min_value=0)

    difficulty_level = StringField(choices=["Easy", "Medium", "Hard"], required=True)

    explanation = StringField()

    # explanation-level images (0..N)
    explanation_images = ListField(EmbeddedDocumentField(Image), default=list)

    tags = ListField(StringField())
    time_limit = IntField()  # in seconds

    topic = StringField(required=True)
    subtopic = StringField()
    created_by = DictField(required=True, default=lambda: {"id": "system", "name": "System"})

    meta = {"abstract": True}

    # ------------------------
    # Validation
    # ------------------------
    def clean(self):
        """Validation before saving."""
        if not self.is_multiple and len(self.correct_options) > 1:
            raise ValidationError("Multiple correct options not allowed unless is_multiple=True")

    # ------------------------
    # Config updater helper (keeps a per-collection MCQConfig)
    # ------------------------
    def _update_config_for_collection(self):
        # Try to determine the collection name for this concrete class
        collection_name = self._meta.get("collection") or getattr(self, "__class__").__name__.lower()

        config = MCQConfig.objects(collection_name=collection_name).first()
        if not config:
            config = MCQConfig(collection_name=collection_name)

        if self.difficulty_level and self.difficulty_level not in config.difficulty_levels:
            config.difficulty_levels.append(self.difficulty_level)

        if self.topic and self.topic not in config.topics:
            config.topics.append(self.topic)

        if self.subtopic and self.subtopic not in config.subtopics:
            config.subtopics.append(self.subtopic)

        for tag in self.tags or []:
            if tag and tag not in config.tags:
                config.tags.append(tag)

        config.save()

    # ------------------------
    # Save override
    # ------------------------
    def save(self, *args, **kwargs):
        """Run validation and update the per-collection MCQConfig after saving."""
        self.clean()
        result = super(BaseMCQ, self).save(*args, **kwargs)
        try:
            self._update_config_for_collection()
        except Exception:
            # Don't fail saving the MCQ if config update has an issue; raise if you prefer strict behavior
            pass
        return result
    # ------------------------
    # JSON for student test (minimal)
    # ------------------------
    def to_student_test_json(self):
        def img_to_dict(img):
            return {
                "image_id": img.image_id,
                "label": img.label,
                "url": img.url,
                "alt_text": img.alt_text,
                "metadata": img.metadata,
            }

        return {
            "id": str(self.id),
            "title": self.title,
            "question_text": self.question_text,
            "question_images": [img_to_dict(i) for i in (self.question_images or [])],
            "options": [
                {
                    "option_id": o.option_id,   # keep for answer mapping
                    "value": o.value,
                    "images": [img_to_dict(ii) for ii in (o.images or [])],
                }
                for o in (self.options or [])
            ],
            "is_multiple": self.is_multiple,
        }

    # ------------------------
    # JSON serialization helper
    # ------------------------
    def to_json(self):
        def img_to_dict(img):
            return {
                "image_id": img.image_id,
                "label": img.label,
                "url": img.url,
                "alt_text": img.alt_text,
                "metadata": img.metadata,
            }

        return {
            "id": str(self.id),
            "title": self.title,
            "question_text": self.question_text,
            "question_images": [img_to_dict(i) for i in (self.question_images or [])],
            "options": [
                {
                    "option_id": o.option_id,
                    "value": o.value,
                    "images": [img_to_dict(ii) for ii in (o.images or [])],
                }
                for o in (self.options or [])
            ],
            "correct_options": self.correct_options,
            "is_multiple": self.is_multiple,
            "marks": self.marks,
            "negative_marks": self.negative_marks,
            "difficulty_level": self.difficulty_level,
            "explanation": self.explanation,
            "explanation_images": [img_to_dict(i) for i in (self.explanation_images or [])],
            "tags": self.tags,
            "time_limit": self.time_limit,
            "topic": self.topic,
            "subtopic": self.subtopic,
            "created_by": self.created_by,
        }


# ------------------------
# Concrete collections
# ------------------------
class MCQ(BaseMCQ):
    """Regular MCQs collection (collection name: mcqs)"""
    meta = {"collection": "mcqs"}


class CourseMCQ(BaseMCQ):
    meta = {"collection": "course_mcqs"}



class TestMCQ(BaseMCQ):
    meta = {"collection": "test_mcqs"}



class CollegeMCQ(BaseMCQ):
    college_id = StringField(required=True)  # âœ… mandatory field for college linkage

    meta = {"collection": "college_mcqs"}

    def to_json(self):
        base_json = super().to_json()
        base_json["college_id"] = self.college_id
        return base_json