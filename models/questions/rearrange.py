# models/rearrange.py

import uuid
from mongoengine import (
    Document, EmbeddedDocument,
    StringField, ListField, EmbeddedDocumentField,
    IntField, BooleanField, FloatField, DictField
)


# ------------------------
# Reusable Image embedded doc
# ------------------------
class Image(EmbeddedDocument):
    """Reusable image structure with autogenerated id, label, url, alt text and optional metadata."""
    image_id = StringField(required=True, default=lambda: str(uuid.uuid4()))
    label = StringField()             # a human readable label for the image (optional)
    url = StringField(required=True)  # URL to the image (should be validated by caller)
    alt_text = StringField()          # alt / description text for accessibility
    metadata = DictField()            # any extra metadata (uploader, size, mime, etc.)


# ------------------------
# Item (now supports images)
# ------------------------
class Item(EmbeddedDocument):
    """Single item/segment for a rearrange question"""
    item_id = StringField(required=True, default=lambda: str(uuid.uuid4()))
    value = StringField(required=True)  # text/html of the item
    images = ListField(EmbeddedDocumentField(Image), default=list)  # optional images for the item


# ------------------------
# Config document (unchanged collection name)
# ------------------------
class RearrangeConfig(Document):
    """Stores Config data auto-created from Rearrange questions"""
    difficulty_levels = ListField(StringField())
    topics = ListField(StringField())
    subtopics = ListField(StringField())
    tags = ListField(StringField())

    meta = {"collection": "rearrange_configs"}


# ------------------------
# Abstract/Base Rearrange model
# ------------------------
class BaseRearrange(Document):
    """Abstract base for rearrange-like questions.

    Put shared fields & validation here so other collections (e.g., course_rearranges)
    can inherit the same behavior.
    """
    title = StringField(required=True)
    prompt = StringField(required=True)  # main question/prompt shown to the student

    # question-level images (0..N)
    question_images = ListField(EmbeddedDocumentField(Image), default=list)

    items = ListField(EmbeddedDocumentField(Item), required=True)
    # correct_order is a list of item_ids in the intended correct sequence
    correct_order = ListField(StringField(), required=True)

    is_drag_and_drop = BooleanField(default=True)  # optional UX hint

    marks = FloatField(required=True, min_value=0)
    negative_marks = FloatField(required=True, min_value=0)

    difficulty_level = StringField(choices=["Easy", "Medium", "Hard"], required=True)

    explanation = StringField()
    # explanation-level images (0..N)
    explanation_images = ListField(EmbeddedDocumentField(Image), default=list)

    tags = ListField(StringField())
    time_limit = IntField()  # in seconds

    topic = StringField(required=True)
    subtopic = StringField()
    created_by = DictField(required=True, default=lambda: {"id": "system", "name": "System"})

    meta = {"abstract": True}

    def clean(self):
        """Validation before saving (keeps original rules)"""
        # Ensure items are present
        if not self.items or len(self.items) == 0:
            raise ValueError("At least one item is required")

        item_ids = [it.item_id for it in self.items]

        # correct_order must contain exactly the same ids as items (same length, no unknowns, no duplicates)
        if len(self.correct_order) != len(item_ids):
            raise ValueError("correct_order must contain the same number of ids as items")

        if set(self.correct_order) != set(item_ids):
            raise ValueError("correct_order must be a permutation of item ids from `items`")

        if len(self.correct_order) != len(set(self.correct_order)):
            raise ValueError("correct_order contains duplicate item ids")

        # additional sanity: non-negative time_limit if provided
        if self.time_limit is not None and self.time_limit < 0:
            raise ValueError("time_limit must be non-negative")

    def _update_config_for_collection(self):
        """Maintain a single RearrangeConfig that accumulates difficulty/topics/tags.

        This mimics the previous behavior: a single config document (not per-collection)
        is used. If you prefer per-collection configs, adapt this to use collection names.
        """
        config = RearrangeConfig.objects.first()
        if not config:
            config = RearrangeConfig()

        if self.difficulty_level and self.difficulty_level not in config.difficulty_levels:
            config.difficulty_levels.append(self.difficulty_level)

        if self.topic and self.topic not in config.topics:
            config.topics.append(self.topic)

        if self.subtopic and self.subtopic not in config.subtopics:
            config.subtopics.append(self.subtopic)

        for tag in self.tags or []:
            if tag and tag not in config.tags:
                config.tags.append(tag)

        config.save()

    def save(self, *args, **kwargs):
        """Run validation and update the RearrangeConfig after saving."""
        self.clean()
        result = super(BaseRearrange, self).save(*args, **kwargs)
        try:
            self._update_config_for_collection()
        except Exception:
            # Keep same tolerant behavior: don't fail the save if config update has issues.
            pass
        return result

    def to_json(self):
        """Convert Rearrange document to dict/JSON"""
        def img_to_dict(img):
            return {
                "image_id": img.image_id,
                "label": img.label,
                "url": img.url,
                "alt_text": img.alt_text,
                "metadata": img.metadata,
            }

        return {
            "id": str(self.id),
            "title": self.title,
            "prompt": self.prompt,
            "question_images": [img_to_dict(i) for i in (self.question_images or [])],
            "items": [
                {
                    "item_id": it.item_id,
                    "value": it.value,
                    "images": [img_to_dict(ii) for ii in (it.images or [])],
                }
                for it in (self.items or [])
            ],
            "correct_order": self.correct_order,
            "is_drag_and_drop": self.is_drag_and_drop,
            "marks": self.marks,
            "negative_marks": self.negative_marks,
            "difficulty_level": self.difficulty_level,
            "explanation": self.explanation,
            "explanation_images": [img_to_dict(i) for i in (self.explanation_images or [])],
            "tags": self.tags,
            "time_limit": self.time_limit,
            "topic": self.topic,
            "subtopic": self.subtopic,
            "created_by": self.created_by,
        }


# ------------------------
# Concrete Rearrange collection (unchanged collection name)
# ------------------------
class Rearrange(BaseRearrange):
    """Model for a 'rearrange these items in correct order' question"""
    meta = {"collection": "rearranges"}
    
class CourseRearrange(BaseRearrange):
    """Model for a 'rearrange these items in correct order' question"""
    meta = {"collection": "course_rearrange"}


 
     
class CollegeRearrange(BaseRearrange):
    college_id = StringField(required=True)  # âœ… mandatory field for college linkage

    """Model for a 'rearrange these items in correct order' question"""
    meta = {"collection": "college_rearrange"}
    def to_json(self):
        base_json = super().to_json()
        base_json["college_id"] = self.college_id
        return base_json

class TestRearrange(BaseRearrange):
    """Model for a 'rearrange these items in correct order' question"""
    meta = {"collection": "course_rearrange"}
